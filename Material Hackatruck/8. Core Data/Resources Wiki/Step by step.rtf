{\rtf1\ansi\ansicpg1252\cocoartf1504
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;\csgray\c100000;\csgenericrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww20840\viewh12360\viewkind0
\deftab543
\pard\tx543\pardeftab543\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \CocoaLigature0    \
     Passos:\
     \
     1. Criar projeto utilizando Core Data (ou incluir o objeto DataModel e o \'93Core Data stack\'94 em um projeto j\'e1 existente).\
     2. Criar a estrutura do banco de dados no model: tabelas, campos, tipos dos dados, relacionamentos. \'c9 poss\'edvel adicionar valida\'e7\'f5es aos campos, se necess\'e1rio. N\'e3o se esque\'e7a de definir os tipos de relacionamentos: para um ou para muitos.\
	 3. Neste exemplo, utilizamos classes dentro do projeto para enviar/buscar objetos do banco, mas \'e9 poss\'edvel enviar diretamente para o banco, sem o uso das classes (consulte a documenta\'e7\'e3o oficial do Core Data). Para fazer utilizando as classes, selecione as tabelas do projeto e modifique as seguintes propriedades no Data Model Inspector (menu lateral \'e0 direita):\
		- Module: Current Product Module \
		- Codegen: Manual/None\
     4. Gerar as classes para essas tabelas (menu Editor > Create NSManagedObject\'85).\
     5. Verifique se as classes foram geradas corretamente. Elas dever\'e3o estar divididas em 2 partes: CoreDataClass e CoreDataProperties. Qualquer c\'f3digo que precise ser adicionado manualmente nas classes, deve ficar em CoreDataClass, pois a CoreDataProperties deve ter sempre seu conte\'fado gerado automaticamente pela ferramenta, e qualquer c\'f3digo adicionado posteriormente pode ser facilmente perdido.\
	 6. Em cada classe, inclua na parte do CoreDataClass o \'93convenience init\'94, que far\'e1 a rela\'e7\'e3o daquela classe com sua respectiva tabela no banco de dados. Dessa maneira, sempre que um novo objeto for inicializado, ele ter\'e1 informa\'e7\'e3o de em qual tabela dever\'e1 est\'e1 linkado no banco. \
\
At\'e9 aqui criamos o modelo e suas respectivas classes para acessar o banco de dados. Agora, vamos preparar o projeto para fazer isso.\
\
	 7. Crie uma nova classe que ir\'e1 \'93gerenciar\'94 o banco de dados. Um exemplo de nome para ela pode ser CoreDataManager.\
	 8. Mova para l\'e1 todo o conte\'fado abaixo do \'93MARK: Core Data Stack\'94 existente no AppDelegate da aplica\'e7\'e3o e fa\'e7a os devidos ajustes, tornando os objetos e m\'e9todos est\'e1ticos; dessa forma, poderemos acess\'e1-los diretamente sem ter que instanciar a classe. \
	 9. Crie um m\'e9todo getContext() nesta classe, retornando o contexto do banco de dados, para que as demais classes que precisarem acessar o banco possam utiliz\'e1-lo.\
	 10. Crie os m\'e9todos insert() e delete() no CoreDataManager, que recebam como par\'e2metro um objeto NSManagedObject - desta forma, tais m\'e9todos ser\'e3o gen\'e9ricos para qualquer opera\'e7\'e3o de inser\'e7\'e3o ou exclus\'e3o do banco. Para a edi\'e7\'e3o de objetos, utilizaremos o m\'e9todo saveContext() do CoreData.\
	 11. Crie uma classe que armazenar\'e1 os m\'e9todos de busca da entidade (o nome pode ser composto de \'93nome da entidade\'94 + sufixo \'93DAO\'94). A busca poderia ser criada como um m\'e9todo gen\'e9rico dentro do CoreDataManager tamb\'e9m, mas deixaremos numa classe espec\'edfica da entidade para ter flexibilidade para definir filtros, crit\'e9rios de ordena\'e7\'e3o e outros crit\'e9rios que podem ser necess\'e1rios especificamente em cada entidade. Deixe os m\'e9todos de busca est\'e1ticos tamb\'e9m, para que a classe n\'e3o precise ser instanciada.\
     12. Implemente a chamada do m\'e9todo na Controller necess\'e1ria. Evite implementar chamadas a banco dentro de Controllers.\
     \
     \
     }